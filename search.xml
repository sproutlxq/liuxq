<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github Pages + hexo Next 搭建个人博客</title>
    <url>/2020/05/07/Github-Page-hexo-Next-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="一、Github-Pages-和-hexo是什么"><a href="#一、Github-Pages-和-hexo是什么" class="headerlink" title="一、Github Pages 和 hexo是什么"></a>一、Github Pages 和 hexo是什么</h4><p>   Github Pages是github提供的托管个人博客的工具，不过只能存放静态页面。通过修改项目的setting就可以开启Github Pages服务。配置好以后，它会给你一个可以访问的域名，这样你就不用去买服务器和域名以及备案了。</p>
<p>   Hexo 是一个基于 Node.js 的快速、简洁且高效的博客框架，可以方便的生成静态网页托管在github和Heroku上。Hexo 因其界面简洁、美观且对各类人群（不只是程序猿）友好而广受欢迎。<br>   它有以下几个特点：</p>
<p>   超快速度—-Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。<br>   一键部署—-只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。<br>   支持 Markdown—-Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。<br>   丰富的插件—-Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>
<p>   把二者结合起来搭建个人网站，不需要写一行代码，非常迅速。把hexo生成的内容直接push到Github上即可发布网站，博客管理变得非常方便。</p>
<h4 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h4><p><strong>1. 配置好一个Github Pages仓库</strong></p>
<p>   新建一个Github项目,命名规则为： [<code>Github用户名</code>].github.io</p>
<p>   建好以后开始配置Github Pages，步骤是：</p>
<blockquote>
<p>Github项目 -&gt; Setting -&gt; GitHub Pages -&gt; 选择Source</p>
</blockquote>
<p>   不需要选择主题，如果选择主题则默认用Github提供的jekyll工具搭建网站，而我们使用的是hexo。到这里Github Pages的访问地址已经有了，但是还没有内容，因此不能访问。</p>
<p><strong>2. npm安装hexo</strong></p>
<p>   首先使用npm安装hexo-cli</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>   看到控制台有安装成功的log后，可以开始使用hexo搭建网站了。</p>
<p>   新建一个项目文件夹，比如我的项目文件夹叫sproutlxq，在windows下的命令是：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir sproutlxq</span><br></pre></td></tr></table></figure>

<p>   cd进入刚才新建的项目文件夹，然后依次运行下面两个命令：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init   #初始化hexo博客</span><br><span class="line">$ npm install   #安装必要组件</span><br></pre></td></tr></table></figure>

<p>   这时候hexo已经为我们创建了一个hello_world的默认网页。但是在新版hexo中，还需要安装一个叫hexo-server的模块，才能启动本地服务。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>   安装成功后启动本地服务：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s   #简写的命令</span><br><span class="line">$ hexo s --debug  #开启debug模式</span><br></pre></td></tr></table></figure>

<p>   当我们看到服务启动成功的提示后，就可以根据提示去访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<p><strong>3. 安装next主题Next</strong></p>
<p>   hexo官方网站上有很多主题，可以选择自己喜欢的主题。按照github上的star数，Next主题是最受欢迎的。我也选择了Next。</p>
<p>   在项目文件夹下面，执行主题安装命令：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>   这个主题会自动被安装到项目文件夹下的themes文件夹内。</p>
<p>   接下来要启用Next 主题，在站点配置文件中配置。<br>   <code>theme: next</code></p>
<p>   到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p>
<p>   运行 <code>hexo s --debug</code> 命令启动本地服务器，如果看到如下界面，说明安装成功了。</p>
<p>   <img src="http://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png" alt="Next 主题"></p>
<p>   Next主题目前提供了五种Scheme供用户选择，默认是Muse，我觉得Pisces也很漂亮，所以更改下主题配置文件<kbd>_config.yml</kbd></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>

<p>   把不启用的scheme先注释掉。刷新页面就可以看到效果了。</p>
<p>   接下来还可以参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">hexo 官方网站</a> ，去配置语言、菜单等内容。</p>
<p>   有兴趣的还可以仔细浏览主题配置文件和站点配置文件，修改自己感兴趣的配置项。</p>
<p><strong>4. 发布到Github</strong></p>
<p>   有两种方式可以把我们上面生成的网站发布到Github上：HTTPS和SSH。HTTPS比较简单，但SSH一劳永逸，我用了SSH的方式，这里偷懒只记录SSH方式。</p>
<p>   首先，要安装hexo-deployer-git组件。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>   看下本地git的配置：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure></p>
<p>   如果没有配置好就配置一下。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name [your name]</span><br><span class="line">git config --global user.email [your email]</span><br></pre></td></tr></table></figure>
<p>   接下来，我们就可以根据上面配置的用户名与邮箱生成SSH公钥私钥（RSA算法），我们将公钥发给GitHub的SSH管理员时，我们如果拿着私钥去访问GitHub，GitHub SSH管理员就可以进行公钥私钥配对，来完成认证。当然，第一次将公钥给GitHub时，GitHub管理员是需要我们输入密码来认证的。</p>
<p>   确认配置过git用户名与邮箱之后，运行以下命令，生成公钥私钥。连续回车使用默认参数。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;  #邮箱为GitHub邮箱</span><br></pre></td></tr></table></figure>

<p>   根据控制台的提示，找到公钥私钥存放的位置。按照下面的步骤把公钥告诉Github。</p>
<blockquote>
<p>将公钥复制 -&gt; 打开GitHub -&gt; settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt; title随便起，将公钥复制到key框中 -&gt; Add SSH key -&gt; 输入GitHub密码 -&gt; 成功。</p>
</blockquote>
<p>   接下来修改站点配置文档 <kbd>_config.yml</kbd></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repository: git@github.com:xxx&#x2F;xxx.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>

<p>   将repository修改为我们Github的ssh地址。SSH地址可以在GitHub -&gt; GitHub page库 -&gt; clone or download -&gt; Use SSH获取.</p>
<p>   修改完成之后，可以运行以下命令来进行部署：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean            #清除之前静态页面</span><br><span class="line">hexo generate            #生成静态页面</span><br><span class="line">hexo deploy(可缩写为d)  # 部署</span><br></pre></td></tr></table></figure></p>
<p>   至此部署完成，访问github page给的地址，就可以看到自己的个人页面了。<br>   <a href="https://sproutlxq.github.io/">https://sproutlxq.github.io/</a></p>
<p><strong>5. 发布新文章</strong></p>
<p>  新建博文的命令是：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [title]</span><br></pre></td></tr></table></figure>

<p>  这时候在post文件夹下就生成了一个新的.md文件，里面就可以写自己的新文章了。</p>
<p>  hexo文章里引用本地图片一般需要使用npm安装新的hexo功能插件，比较麻烦，更推荐使用图床服务，比如：<a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p>
<p><strong>6. 博文备份</strong></p>
<p>   博文备份我还没遇到，没有细研究，先mark一下，需要的时候再试试。</p>
<p>  <a href="https://www.dazhuanlan.com/2019/08/16/5d560f66bf886/?__cf_chl_jschl_tk__=ee3d3dad05b5e8f12886d38e3ee34ed366c1953b-1590503252-0-AZX9LKyDCW2ZIQqWRoO5y6RjGyWYNY_QX-MZ-HWFVa97oUpF1Tbl_u12xDvMn5viVEuDVOGHZ5nb7jhDaXOJEGDUwK8_oc7sA3Q5_pMPb6lZK6hJPSscaX9KBUufRUC2_wNI5VWDJRt9AXaLI_-aMZMMPAbGffnbVPz8Rjm6GRZ45F2mOBwWniiPkT_u73Y2z3Vktn3Rjt803Ocm-uZKNNrqJSMvP4wf6eXG13j633sgw9707eZQMVa4qr96ggGlDkKUwjPn_Tln0_5WuCxyzUs5bPTd-oDlUs9EY9MkFqp61B4LWqPn2tinbQjEwX-xww" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/08/16/5d560f66bf886/?__cf_chl_jschl_tk__=ee3d3dad05b5e8f12886d38e3ee34ed366c1953b-1590503252-0-AZX9LKyDCW2ZIQqWRoO5y6RjGyWYNY_QX-MZ-HWFVa97oUpF1Tbl_u12xDvMn5viVEuDVOGHZ5nb7jhDaXOJEGDUwK8_oc7sA3Q5_pMPb6lZK6hJPSscaX9KBUufRUC2_wNI5VWDJRt9AXaLI_-aMZMMPAbGffnbVPz8Rjm6GRZ45F2mOBwWniiPkT_u73Y2z3Vktn3Rjt803Ocm-uZKNNrqJSMvP4wf6eXG13j633sgw9707eZQMVa4qr96ggGlDkKUwjPn_Tln0_5WuCxyzUs5bPTd-oDlUs9EY9MkFqp61B4LWqPn2tinbQjEwX-xww</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>《TensorFlow学习指南》读书笔记</title>
    <url>/2020/05/01/%E3%80%8ATensorFlow%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>待填坑</p>
]]></content>
  </entry>
  <entry>
    <title>《深入理解ES6》读书笔记</title>
    <url>/2020/05/01/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>产假期间看的书们，我要仔细梳理一下。待填坑</p>
]]></content>
  </entry>
  <entry>
    <title>《用Python进行数据分析》读书笔记</title>
    <url>/2020/05/01/%E3%80%8A%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>待填坑</p>
]]></content>
  </entry>
  <entry>
    <title>为什么建站</title>
    <url>/2020/05/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<p>   2019年我幸运的得到了一个天使宝宝，同时也跨入了我的30岁。有阵痛，但也感到了前所未有的圆满和幸福。<br>   在休产假期间，赶上了2020年的疫情，于是“幸运”的能够在家陪伴宝宝九个半月时间。空闲时沉迷B站，整个人都变得年轻了（国企真的催人老 &amp;&amp; 吐槽脸），然后产生了强烈的愿望，想要在30岁这一年做一些以前不会做的事。</p>
<p>   我的兴趣很多：打单机游戏、电影、游泳、桌游、看小说、做家务、旅游、画画… 除了兴趣，也常常对其他没体验过的事情感到好奇。我一直感觉自己的生活非常丰富多彩，我沉迷于自己的世界，变得越来越懒得与别人深入交流（内心os: 反正你们也不会懂我的乐趣 &amp;&amp; 傲娇脸），习惯与所有人保持着稍稍远一些的距离。</p>
<p>   但是30了，再不改变，也许我就变成了一个固执的老太太，然后就要以现在的面貌一直到老呢。我想试着锻炼下主动与人交流和分享的能力，而不仅仅是因为工作沟通以及朋友主动来找我。那么就从写博客开始吧！</p>
<p>   另一个目的，是希望博客分享的方式，逼迫我把一些知识学得更透彻，事情做到更精细，然后多多总结，并把学过的内容沉淀下来（现在的工作与专业无关，学过的知识用不上，所以遗忘很严重，每年都要重学一遍，真的很浪费时间）。</p>
<p>   这个站的文章可能会很杂，包括学习总结、读书笔记、观影报告、日记等等，所以不想按照分类来组织，搜索的话就依靠Tag。这样我可以在写作灵感乍现的时候没有分类负担的先写下来再说。</p>
<p>   写作频率还是要对自己有些要求的，每个月至少要有一篇学习类的文章（但是不能用太简单的凑数），不然可能像以前一样，轰轰烈烈去购买了域名备了案，但是什么也不想写。</p>
]]></content>
      <tags>
        <tag>日记</tag>
        <tag>第一篇</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS经典面试题-四种方式实现两列布局</title>
    <url>/2020/05/13/CSS%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>   典型的两列布局就是下图这个样子。<br>   外层父容器是<i>.container</i>，左侧有固定宽度的<i>nav</i>，右侧的<i>section</i>自适应宽度。</p>
<p>   常见的面试题还有在这个基础上增加header、footer。footer固定在页面底部，无论页面怎样滚动，保持固定宽度和位置。<br>   本文用四种方式实现下图的两列布局，顺便可以复习一下CSS Layout的部分知识。</p>
<p>   <img src="https://i.loli.net/2020/06/01/5fVHKr6DO79FIXk.png" alt="two-column.PNG"></p>
<p>   这个例子的html结构和基本的样式如下，我在此基础上添加布局样式实现两列布局。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    &#x2F;* 基本样式 *&#x2F;</span><br><span class="line">    body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div, nav, section, header, footer &#123;</span><br><span class="line">        box-sizing: border-box; </span><br><span class="line">        border: solid 1px #000000;</span><br><span class="line">    &#125;</span><br><span class="line">    header &#123;</span><br><span class="line">        background-color: brown;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 80px;</span><br><span class="line">    &#125;</span><br><span class="line">    footer &#123;</span><br><span class="line">        background-color: cornflowerblue;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 120px;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &#123;</span><br><span class="line">        height: 500px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;   </span><br><span class="line">    nav &#123;</span><br><span class="line">        height: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    section &#123;</span><br><span class="line">        height: 700px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;* 布局样式 *&#x2F;</span><br><span class="line">    &#x2F;* 添加在这里 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;header&gt;我是固定宽高的header，高度为80px&lt;&#x2F;header&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;nav&gt;这是左边的栏目，固定宽度200px&lt;&#x2F;nav&gt;</span><br><span class="line">        &lt;section&gt;这是右边的栏目，占据屏幕剩下的宽度&lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;我是固定在页面底部的footer，我的高度是120px&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></code></pre><h4 id="第一种方式：利用absolute-postion实现"><a href="#第一种方式：利用absolute-postion实现" class="headerlink" title="第一种方式：利用absolute postion实现"></a>第一种方式：利用absolute postion实现</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nav &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0; </span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">section &#123;</span><br><span class="line">    margin-left: 200px;</span><br><span class="line">&#125;</span><br><span class="line">footer &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   这个实现涉及到了position的各个属性： relative、absolute、fixed，还有一个无处不在的ststic。</p>
<p>   static 是默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。</p>
<p>   relative 表现的和 static 一样，除非你添加了一些额外的属性。在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其<strong>偏离其正常位置</strong>。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</p>
<p>   一个固定定位（position属性的值为fixed）元素会<strong>相对于视窗来定位</strong>，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。<br>   一个固定定位元素不会保留它原本在页面应有的空隙（脱离文档流）。</p>
<p>   absolute 是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是<strong>相对于最近的“positioned”祖先元素</strong>。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。</p>
<p>   看明白以上position属性的表现就能理解第一种解决方案。</p>
<h4 id="第二种方式：利用float实现"><a href="#第二种方式：利用float实现" class="headerlink" title="第二种方式：利用float实现"></a>第二种方式：利用float实现</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    height: 500px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;   </span><br><span class="line">nav &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">section &#123;</span><br><span class="line">    margin-left: 200px;</span><br><span class="line">&#125;</span><br><span class="line">footer &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   float 属性定义元素在哪个方向浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。<br>   float设计的初衷并不是用来布局的，其本意仅仅是实现图片文字环绕效果，即图片左浮动，文字环绕图片。</p>
<p>   一个元素设置了float属性，会表现出如下特性：</p>
<ol>
<li>包裹性：一个浮动元素，如果子元素宽度足够小，则浮动元素的宽度就是该子元素的宽度；如果浮动元素的父元素有设置宽度，并且浮动元素的子元素宽度超出了父元素，则浮动元素的宽度最终表现为父元素的宽度。</li>
</ol>
<ol start="2">
<li><p>块状格式化上下文：设定了float的元素，其display的最终值会表现为block或者table(除了inline-table)。<br>因此，设置了float的元素，下面的写法是多余的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.float &#123;</span><br><span class="line">    float: left:</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">.float &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    vertical-align: middle; &#x2F;* 不起作用 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>破坏文档流：设置float的元素，会导致父元素高度塌陷。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">   &lt;img src&#x3D;&quot;.&#x2F;card.jpg&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;float&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕</span><br><span class="line">&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://image-static.segmentfault.com/301/078/3010780609-5b826252cec40_articlex" alt="float父元素高度塌陷"></p>
<p>可以看到父元素<i>father</i>的高度为0。</p>
<p>这里还有一个隐藏特性，为了让文字浮动上去后不会盖在图片上，盒模型元素不会与浮动元素互相遮盖，因此给文字设置margin的负值也没有用。</p>
</li>
</ol>
<ol start="4">
<li>没有margin合并</li>
</ol>
<p>   其实，就像前面说的，float本来不是用来实现布局的，如果一个页面比较复杂，用float常常会产生很多问题，因此不推荐用这个方法来实现两列布局 or 多列布局。</p>
<h4 id="第三种方式：利用display：inline-block实现"><a href="#第三种方式：利用display：inline-block实现" class="headerlink" title="第三种方式：利用display：inline-block实现"></a>第三种方式：利用display：inline-block实现</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: top;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: top;</span><br><span class="line">&#125;</span><br><span class="line">footer &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   display: inline-block这个属性很简单，改变了盒模型的默认显示方式。这种实现方式要注意的是应该添加vertical-align: top;属性，这样左右两列高度不一致时也能够对齐。</p>
<p>   但是这个方法有一个要求： 右侧的内容必须足够多，能够填充剩余宽度。</p>
<h4 id="第四种方式：利用flex实现"><a href="#第四种方式：利用flex实现" class="headerlink" title="第四种方式：利用flex实现"></a>第四种方式：利用flex实现</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: -webkit-flex;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">nav &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">section &#123;</span><br><span class="line">    -webkit-flex: 1;</span><br><span class="line">            flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">footer &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   flex布局这里就不详细解释了，阮一峰老师的Flex教程写的很详细了，不过我用到的机会好少/(ㄒoㄒ)/~~太不熟练了</p>
<p>   参考链接： <a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">http://zh.learnlayout.com/</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>懒加载</title>
    <url>/2020/06/01/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>   这周接到了做一个公司卡通主题形象投票活动的需求，页面意外的设计的还蛮漂亮的（真的是喜欢二次元的设计风格哈哈）。我已经很久没有自己写这种简单页面了，这次的需求很难得的让我产生了兴趣，决定自己来开发。</p>
<p>   既然要写就要有练手效果才行，所以我想把各个细节做到最好，比如鼠标交互时的自定义样式（又当切图仔又当设计的去找了好看的资源），比如textarea的样式、校验和控制，比如尽量用最少的CSS代码量实现布局… 不过最后花了我最多时间的是懒加载。</p>
<p>   页面上有不少信息量丰富的图片，我决定把大图们做一些切割，逐步来加载。好几年前面试的时候曾经看过懒加载的知识，但其实挺少碰到这种图片多到需要去用懒加载做性能优化的场景，还没有真的用过。随手搜了下帖子，发现这个东西其实没有那么简单。这篇文章就用来总结一下吧。</p>
<h4 id="一、-什么是懒加载"><a href="#一、-什么是懒加载" class="headerlink" title="一、 什么是懒加载"></a>一、 什么是懒加载</h4><p>   懒加载简单说就是延迟加载、按需加载，常常和预加载作为相对概念一起提及。最常见的应用场景是：</p>
<blockquote>
<p>页面较长，屏幕的可视区域有限。先不加载不可见区域的图片，等到进入视口可见位置时才开始加载。</p>
</blockquote>
<p>   浏览器有自己的资源加载优先级。<br>   <img src="https://hateonion.me/posts/19jan30/resource-priority.jpg" alt="浏览器加载资源顺序"></p>
<p>   在开发者工具中打开priority，可以看到浏览器加载资源的优先级。<br>   <img src="https://hateonion.me/posts/19jan30/image-high-priority.jpg" alt="image-high-priority"></p>
<p>   这些优先级标记为high的图片会占用其他资源的下载带宽，可能会造成某些比较关键的资源（比如xhr call）加载缓慢，拖慢页面速度。</p>
<p>   用懒加载可以降低这些暂时不是“刚需”的图片资源的优先级，缩短onload事件时间。下图是应用了懒加载之后的优先级。<br>   <img src="https://hateonion.me/posts/19jan30/image-lazy-load.jpg" alt="image-lazy-load"></p>
<h4 id="二、-基础版懒加载"><a href="#二、-基础版懒加载" class="headerlink" title="二、 基础版懒加载"></a>二、 基础版懒加载</h4><p>   页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。所以懒加载的实现思路是：</p>
<blockquote>
<p>不设置页面中<code>img</code>标签的<code>src</code>属性值或者将其指向同一个占位图。图片的实际地址存在<code>img</code>标签自定义的一个属性中，如：<code>data-src</code>。监听scroll(或resize、orientationChange)事件，根据scrollTop判断图片是否在视口内，滚动到某个位置时，如果在视口内，则动态的将<code>url</code>替换成实际的<code>data-src</code>。这个时候浏览器才会去加载图片。</p>
</blockquote>
<p>   <img src="https://lilywei739.github.io/img/20170206/20170206-1.jpg" alt="视口位置"></p>
<ol>
<li><p>可视窗口高度：<br>window.innerHeight(标准模式)<br>document.documentElement.clientHeight(兼容IE9以下浏览器)<br>document.body.clientHeight(混杂模式)</p>
</li>
<li><p>浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离：<br>window.pagYoffset(标准模式)<br>document.documentElement.scrollTop(兼容IE9以下浏览器)<br>document.body.scrollTop(混杂模式)</p>
</li>
<li><p>元素的尺寸(outerWidth)：e.offsetWidth</p>
</li>
<li><p>元素距文档顶部的距离：e.offsetTop</p>
<p>当offsetTop - scroolTop &lt; clientHeight，则图片进入了可视区内，即：<br>offsetTop &lt; clientHeight + scroolTop</p>
<p>具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Lazyload 1&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        img &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        margin-bottom: 50px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;1.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;2.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;3.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;4.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;5.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;6.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;7.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;8.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;9.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;10.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;11.png&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;loading.gif&quot; data-src&#x3D;&quot;images&#x2F;12.png&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function lazyload() &#123;</span><br><span class="line">            var images &#x3D; document.getElementsByTagName(&#39;img&#39;);</span><br><span class="line">            var len    &#x3D; images.length;</span><br><span class="line">            var n      &#x3D; 0;      &#x2F;&#x2F;存储图片加载到的位置，避免每次都从第一张图片开始遍历		</span><br><span class="line">            return function() &#123;</span><br><span class="line">                var seeHeight &#x3D; document.documentElement.clientHeight;</span><br><span class="line">                var scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">                for(var i &#x3D; n; i &lt; len; i++) &#123;</span><br><span class="line">                    if(images[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">                        if(images[i].getAttribute(&#39;src&#39;) &#x3D;&#x3D;&#x3D; &#39;images&#x2F;loading.gif&#39;) &#123;</span><br><span class="line">                            images[i].src &#x3D; images[i].getAttribute(&#39;data-src&#39;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        n &#x3D; n + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var loadImages &#x3D; lazyload();</span><br><span class="line">        loadImages();          &#x2F;&#x2F;初始化首页的页面图片</span><br><span class="line">        window.addEventListener(&#39;scroll&#39;, loadImages, false);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="三、-使用getBoundingClientRect方法实现懒加载"><a href="#三、-使用getBoundingClientRect方法实现懒加载" class="headerlink" title="三、 使用getBoundingClientRect方法实现懒加载"></a>三、 使用getBoundingClientRect方法实现懒加载</h4><p>   在上面的方法中，使用了三个元素计算属性来判断，且要兼顾各种浏览器，比较麻烦。getBoundingClientRect方法只需要一行代码就可以得到元素相对视口的位置。<br>   目前常见浏览器都支持getBoundingClientRect。</p>
<p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">Element.getBoundingClientRect()</a>返回一个DOMRect object。具体结构如下：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    top: &#39;元素顶部相对于视口顶部的距离&#39;,</span><br><span class="line">    bottom: &#39;元素底部相对于视口顶部的距离&#39;,</span><br><span class="line">    left: &#39;元素左边相对于视口左边的距离&#39;,</span><br><span class="line">    right: &#39;元素右边相对于视口左边的距离&#39;,</span><br><span class="line">    height: &#39;元素高度&#39;,</span><br><span class="line">    width: &#39;元素宽度&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   所以上述if的判断条件改为：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">bound &#x3D; images[i].getBoundingClientRect();</span><br><span class="line">if(bound.top &lt;&#x3D; clientHeight) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   使用getBoundingClientRect方法来实现，虽然很简单，也可以很好兼容，但有个缺点：<br>   由于scroll事件密集发生，计算量很大，容易造成性能问题。</p>
<h4 id="四、-节流与防抖"><a href="#四、-节流与防抖" class="headerlink" title="四、 节流与防抖"></a>四、 节流与防抖</h4><p>   在上面的解决方案中，scroll频繁触发，所以在做事件绑定的时候，可以对 lazyload 函数进行函数节流（throttle）与函数防抖（debounce）处理。简单的解释就是，如果你一直频繁触发，我就等到你最后一次触发再开始计时，一段时间后稳定下来我再执行，但同时在某个最小时间范围内我至少要执行一次。</p>
<p>   在一段时间内至少执行一次scroll响应，且每次频繁触发要延迟一段时间执行scroll响应，如果这段延迟时间内重复触发，那么就重新计时。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn, delay, atleast) &#123;</span><br><span class="line">    var timeout &#x3D; null,</span><br><span class="line">    startTime &#x3D; new Date();</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var curTime &#x3D; new Date();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        if(curTime - startTime &gt;&#x3D; atleast) &#123;</span><br><span class="line">            fn();</span><br><span class="line">            startTime &#x3D; curTime;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(fn, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(loadImages, 500, 1000), false);</span><br></pre></td></tr></table></figure>

<p>   设置了 500ms 的延迟，和 1000ms 的间隔，当超过 1000ms 未触发该函数，则立即执行该函数，不然则延迟 500ms 执行该函数。</p>
<h4 id="五、-使用IntersectionObserver-API实现懒加载"><a href="#五、-使用IntersectionObserver-API实现懒加载" class="headerlink" title="五、 使用IntersectionObserver API实现懒加载"></a>五、 使用IntersectionObserver API实现懒加载</h4><p>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">IntersectionObserver API</a>可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<p>   使用IntersectionObserver API来实现懒加载不需要自己去绑定事件，只需要定义回调函数即可。目前只有包括chrome 51以上，但不包括IE的部分浏览器支持。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var io &#x3D; new IntersectionObserver(callback, option);</span><br></pre></td></tr></table></figure>
<p>   构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始观察</span><br><span class="line">io.observe(document.getElementById(&#39;example&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 停止观察</span><br><span class="line">io.unobserve(element);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关闭观察器</span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>

<p>   callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。</p>
<ol>
<li><p>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</p>
</li>
<li><p>target：被观察的目标元素，是一个 DOM 节点对象</p>
</li>
<li><p>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</p>
</li>
<li><p>boundingClientRect：目标元素的矩形区域的信息</p>
</li>
<li><p>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</p>
</li>
<li><p>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0</p>
<p>使用IntersectionObserver API来实现懒加载的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function query(selector) &#123;</span><br><span class="line">    return Array.from(document.querySelectorAll(selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var io &#x3D; new IntersectionObserver(function(items) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        if (item.isIntersecting) &#123;</span><br><span class="line">            var target &#x3D; item.target;</span><br><span class="line">            if(target.getAttribute(&#39;src&#39;) &#x3D;&#x3D; &#39;images&#x2F;loading.gif&#39;) &#123;</span><br><span class="line">                target.src &#x3D; target.getAttribute(&#39;data-src&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">query(&#39;img&#39;).forEach(function(item) &#123;</span><br><span class="line">    io.observe(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="六、-原生chrome支持懒加载"><a href="#六、-原生chrome支持懒加载" class="headerlink" title="六、 原生chrome支持懒加载"></a>六、 原生chrome支持懒加载</h4><p>   Chrome浏览器的IMG图片和IFRAME框架会支持原生懒加载特性，使用loading=”lazy”语法。<br>   以下是浏览器支持情况：</p>
<p>   <img src="https://image.zhangxinxu.com/image/blog/201909/2019-09-29_212826.png" alt="Lazy loading 浏览器支持情况"></p>
<p>   如果你想要让一张图片在靠近浏览器视窗的时候才加载，下面代码就可以了：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;.&#x2F;example.jpg&quot; loading&#x3D;&quot;lazy&quot; alt&#x3D;&quot;zhangxinxu&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>   更多的关于这个特性的研究参考下面链接：</p>
<p>   <a href="https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/?shrink=1" target="_blank" rel="noopener">chrome原生支持lazyloading</a></p>
<p>   这个特性实在太棒了，可惜通用还需要时间。</p>
<h4 id="七、-background-image"><a href="#七、-background-image" class="headerlink" title="七、 background-image"></a>七、 background-image</h4><p>   有时候页面的图片不是通过src，而是通过给element添加background-image这个CSS属性实现的。<br>   这个时候只要给element添加一个lazy类，先将background-image设为none,等到元素在视口出现时移除lazy类即可。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bg-image.lazy &#123;</span><br><span class="line">    background-image: none;</span><br><span class="line">&#125;</span><br><span class="line">#bg-image &#123;</span><br><span class="line">    background-image: url(&quot;https:&#x2F;&#x2F;ik.imagekit.io&#x2F;demo&#x2F;img&#x2F;image1.jpeg?tr&#x3D;w-400,h-300&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class="line">    var lazyloadElements &#x3D; document.querySelectorAll(&quot;.lazy&quot;);</span><br><span class="line">    var io &#x3D; new IntersectionObserver(function(items, observer) &#123;</span><br><span class="line">        items.forEach(function(item) &#123;</span><br><span class="line">            if (item.isIntersecting) &#123;</span><br><span class="line">                var element &#x3D; item.target;</span><br><span class="line">                item.classList.remove(&quot;lazy&quot;);</span><br><span class="line">                io.unobserve(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    lazyloadElements.forEach(function(element) &#123;</span><br><span class="line">        io.observe(element);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="八、-进一步优化"><a href="#八、-进一步优化" class="headerlink" title="八、 进一步优化"></a>八、 进一步优化</h4><p>   其实懒加载还有很多可以优化的地方，比如说：</p>
<ol>
<li>根据滚动速度提前加载几屏的图片，而不是等到出现在视口时再去加载，提前加载的范围根据滚动的速度来计算</li>
<li>placeholder尺寸不确定时，如何保证加载时页面不reflow从而出现抖动</li>
<li>如果懒加载失败，可以点击图片再次发起请求</li>
</ol>
<p>   这一节先挖个坑，有空再写上面三个场景怎么处理。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25455672</a></li>
<li><a href="https://segmentfault.com/a/1190000017795499" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017795499</a></li>
<li><a href="https://juejin.im/post/5e84a7d7f265da47ec762306" target="_blank" rel="noopener">https://juejin.im/post/5e84a7d7f265da47ec762306</a></li>
<li><a href="https://hateonion.me/posts/19jan30/" target="_blank" rel="noopener">https://hateonion.me/posts/19jan30/</a></li>
</ol>
]]></content>
      <tags>
        <tag>懒加载</tag>
        <tag>Lazyload</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>移动适配性学习总结</title>
    <url>/2020/08/23/%E7%A7%BB%E5%8A%A8%E9%80%82%E9%85%8D%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="一、-相关概念"><a href="#一、-相关概念" class="headerlink" title="一、 相关概念"></a>一、 相关概念</h4><ol>
<li><p>物理像素(physical pixel)</p>
<p>物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。</p>
</li>
<li><p>设备独立像素(density-independent pixel)</p>
<p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。英文缩写<strong>DIP</strong>。</p>
</li>
<li><p>CSS像素<br>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称<strong>DIPs</strong>。</p>
</li>
<li><p>屏幕密度<br>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算，英文缩写<strong>PPI</strong>。</p>
</li>
<li><p>设备像素比(device pixel ratio)<br>设备像素比简称为<strong>dpr</strong>，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p>
<blockquote>
<p>设备像素比 ＝ 物理像素 / 设备独立像素</p>
</blockquote>
<p>在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询。</p>
</li>
<li><p>响应式布局与弹性布局</p>
<p>响应式布局不是弹性布局，弹性布局强调等比缩放，100%还原；响应式布局强调不同屏幕要有不同的显示，比如媒体查询。</p>
<p>一般PC上的响应式布局会采用媒体查询、百分比的方式实现，flex也是一种最常见的解决方案，但是这些方案对于移动设备来说，都还不够。</p>
<p>响应式布局是一个更宽泛的概念，而弹性布局可以认为是响应式布局是在移动端的一个具体实现思路。</p>
</li>
</ol>
<h4 id="二、-弹性布局的单位"><a href="#二、-弹性布局的单位" class="headerlink" title="二、 弹性布局的单位"></a>二、 弹性布局的单位</h4><ol>
<li><p>em</p>
<p>MDN的定义：</p>
<blockquote>
<p>em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小</p>
</blockquote>
<p>举一个例子：</p>
<p><img src="https://i.loli.net/2020/08/31/rUHGqNRDueQSbPy.jpg" alt="em"></p>
<p>在这个例子中，各元素字体大小和行高分别为：<br><img src="https://i.loli.net/2020/08/31/FstCJOrPpv32IMw.jpg" alt="D4548DD3E9BA4E1C83FE8733906CB5D7.jpg"><br><img src="https://i.loli.net/2020/08/31/XOutHYpLQTvsJdl.jpg" alt="D4548DD3E9BA4E1C83FE8733906CB5D7.jpg"></p>
<p>p2 line-height: 2  表示自身字体大小的两倍</p>
<p>em就是为字体和行高而生的，有些时候子元素字体就应该相对于父元素，元素行高就应该相对于字体大小，但是用作响应式布局时，复杂的计算让人诟病。</p>
</li>
<li><p>rem</p>
<p>MDN的定义：</p>
<blockquote>
<p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小</p>
</blockquote>
<p>与em比较，rem是相对根元素而不是父元素，这样做弹性布局时不会牵一发而动全身。rem的优点在于统一的参考系。</p>
<p><img src="https://s1.ax1x.com/2020/09/01/djz2wQ.jpg" alt="djz2wQ.jpg"></p>
<p>rem布局的本质是等比缩放，一般是基于宽度。假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示，x = 屏幕宽度 / 100，如果将x作为单位，x前面的数值就代表屏幕宽度的百分比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;width: 50x&#125; &#x2F;* 屏幕宽度的50% *&#x2F;</span><br></pre></td></tr></table></figure>

<p>如果想要页面元素随着屏幕宽度等比变化，我们需要上面的x单位，不幸的是css中并没有这样的单位，幸运的是在css中有rem，通过rem这个桥梁，可以实现神奇的x。</p>
<p>通过上面对rem的介绍，可以发现，如果子元素设置rem单位的属性，通过更改html元素的字体大小，就可以让子元素实际大小发生变化。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>移动</tag>
        <tag>h5</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>暂停</title>
    <url>/2020/07/15/%E6%9A%82%E5%81%9C/</url>
    <content><![CDATA[<p>   最近开始准备考CFA。既然是金融从业者迟早要攀登的一座高山，我决定不拖着，就在下个生日来临前加油战胜它。</p>
<p>   所以最近更新博客的频率打算慢一点，7月份可能不写新的内容了。</p>
<p>   话说最近在看数量分析里统计学的部分，看了后面忘了前面，还是没有真正理解一些统计设计指标的原理。不管是数据分析还是CFA，统统都要把统计学基础拿下，所以这部分真的值得好好补一补，补到滚瓜烂熟为止。</p>
<p>   题外话： 最近看了本新书《你的夏天还好吗》，我超喜欢。这个作者观察和描写的太细腻了，让我久违的感受到语言不可思议的力量。</p>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>动态高可配置表单探索</title>
    <url>/2020/08/17/%E5%8A%A8%E6%80%81%E9%AB%98%E5%8F%AF%E9%85%8D%E7%BD%AE%E8%A1%A8%E5%8D%95%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p>   这个月抽空要给一个表单系统换皮肤，因为是老旧的系统，首先需要重构，把表现层逻辑层从内容里抽离出来。这个表单页面维护十几年，非常复杂，几千行，重构的过程眼睛快要看瞎。<br>   其实toB的很多业务系统粗看都是流程驱动表单，而表单又十分复杂。这个问题很普遍，我想趁机把这个问题深入研究一下。</p>
<p>   复杂的表单主要表现在三多： 字段多、字段显示判断多、校验多。目标是有一套动态高可配置的解决方案。<br>   公司的老旧jsp页面改造起来太费劲了，我选择放弃/(ㄒoㄒ)/~~ 为了研究这个问题，我自己用react建了一个表单的场景。按照对问题逐渐深入的顺序，打算按照这个大纲来讲：</p>
<h4 id="一、-场景"><a href="#一、-场景" class="headerlink" title="一、 场景"></a>一、 场景</h4><p>   去年有机会参加了一个项目，几乎对接了公司所有的业务开发组，从某一个业务流程介入，带着部分表单内容发起新的流程。在这个过程中有机会粗略了解了一下这些业务系统，从技术上说主要是 流程驱动 + 表单。流程大体都有流程引擎来控制，但是表单需要单独去开发，有些表单字段多、校验多、控制多，页面写起来很复杂。<br>   下面是一个react实现的表单示例</p>
<h4 id="二、-采用json-scheme配置字段复杂的表单"><a href="#二、-采用json-scheme配置字段复杂的表单" class="headerlink" title="二、 采用json scheme配置字段复杂的表单"></a>二、 采用json scheme配置字段复杂的表单</h4><h4 id="三、-策略模式优化表单校验"><a href="#三、-策略模式优化表单校验" class="headerlink" title="三、 策略模式优化表单校验"></a>三、 策略模式优化表单校验</h4><h4 id="四、-前后台结合动态生成表单"><a href="#四、-前后台结合动态生成表单" class="headerlink" title="四、 前后台结合动态生成表单"></a>四、 前后台结合动态生成表单</h4><h4 id="五、-动态高可配置表单解决方案"><a href="#五、-动态高可配置表单解决方案" class="headerlink" title="五、 动态高可配置表单解决方案"></a>五、 动态高可配置表单解决方案</h4><p>   表单这个问题其实很复杂，这篇文章只能触及到皮毛，但是这个业务场景本身是值得持续研究下去的，未来还可能继续更新。</p>
]]></content>
      <tags>
        <tag>表单</tag>
        <tag>json scheme</tag>
      </tags>
  </entry>
</search>
